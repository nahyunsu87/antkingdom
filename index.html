<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>ê°œë¯¸ë“¤ì˜ ë‹¬ì½¤í•œ ì™•êµ­</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Gaegu:wght@400;700&display=swap');
        
        body {
            font-family: 'Gaegu', cursive;
            overflow: hidden;
            touch-action: none; /* ëª¨ë°”ì¼ì—ì„œ ìŠ¤í¬ë¡¤ ë°©ì§€ */
            background-color: #333;
        }
        canvas {
            display: block;
        }
        .ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            padding: 1rem;
        }
        .hud-panel {
            background: rgba(255, 255, 255, 0.9);
            border-radius: 1rem;
            padding: 0.5rem 1rem;
            box-shadow: 0 4px 6px rgba(0,0,0,0.3);
            pointer-events: auto;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        .btn {
            background: #FF9F1C;
            color: white;
            border: none;
            padding: 0.5rem 1rem;
            border-radius: 0.5rem;
            font-size: 1.1rem;
            font-weight: bold;
            cursor: pointer;
            transition: transform 0.1s;
            box-shadow: 0 2px 0 #E08E0B;
        }
        .btn:active {
            transform: translateY(2px);
            box-shadow: none;
        }
        .btn:disabled {
            background: #ccc;
            box-shadow: none;
            cursor: not-allowed;
        }
        .toast {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0,0,0,0.7);
            color: white;
            padding: 10px 20px;
            border-radius: 20px;
            opacity: 0;
            transition: opacity 0.5s;
            pointer-events: none;
        }
    </style>
</head>
<body>

    <!-- Canvas Layer -->
    <canvas id="gameCanvas"></canvas>

    <!-- UI Layer -->
    <div class="ui-layer">
        <!-- Top HUD -->
        <div class="flex justify-between w-full">
            <div class="hud-panel">
                <span class="text-2xl">ğŸ¬</span>
                <span id="scoreDisplay" class="text-2xl font-bold text-gray-800">0</span>
            </div>
            <div class="hud-panel">
                <span class="text-xl">ğŸœ ê°œë¯¸: </span>
                <span id="antCountDisplay" class="text-xl font-bold ml-2">5</span>
            </div>
        </div>

        <!-- Bottom Controls -->
        <div class="flex justify-center mb-4">
            <button id="buyAntBtn" class="btn">
                ìƒˆ ê°œë¯¸ ë¶€í™” (ì‚¬íƒ• 50ê°œ)
            </button>
        </div>
    </div>

    <!-- Instructions / Toast -->
    <div id="toast" class="toast">ë•…ì„ í„°ì¹˜í•´ì„œ ê°„ì‹ì„ ì£¼ì„¸ìš”!</div>

    <script>
        /**
         * ê²Œì„ ì„¤ì • ë° ìƒìˆ˜
         */
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        
        // ë””ì €íŠ¸ ì´ëª¨ì§€ 15ì¢…
        const TREATS = ['ğŸ¬', 'ğŸ­', 'ğŸ«', 'ğŸ©', 'ğŸª', 'ğŸ§', 'ğŸ°', 'ğŸ¥¨', 'ğŸ¥', 'ğŸ¥¯', 'ğŸ§‡', 'ğŸ¥', 'ğŸŒ­', 'ğŸŸ', 'ğŸ•'];
        
        // ê²Œì„ ìƒíƒœ
        const state = {
            score: 0,
            ants: [],
            foods: [],
            particles: [],
            lastTime: 0,
            groundY: 0, // ì§€ìƒê³¼ ì§€í•˜ì˜ ê²½ê³„ì„ 
            nestEntrance: { x: 0, y: 0 },
            rooms: [] // ì§€í•˜ ë°©ë“¤ì˜ ìœ„ì¹˜
        };

        // UI ìš”ì†Œ
        const scoreEl = document.getElementById('scoreDisplay');
        const antCountEl = document.getElementById('antCountDisplay');
        const buyBtn = document.getElementById('buyAntBtn');
        const toast = document.getElementById('toast');

        // ì˜¤ë””ì˜¤ ì»¨í…ìŠ¤íŠ¸ (ê°„ë‹¨í•œ íš¨ê³¼ìŒìš© - ë¸Œë¼ìš°ì € ì •ì±…ìƒ ì‚¬ìš©ì ìƒí˜¸ì‘ìš© í›„ ì´ˆê¸°í™” í•„ìš”)
        let audioCtx = null;

        function initAudio() {
            if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        }

        function playSound(type) {
            if (!audioCtx) return;
            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            osc.connect(gain);
            gain.connect(audioCtx.destination);

            if (type === 'drop') {
                osc.type = 'sine';
                osc.frequency.setValueAtTime(800, audioCtx.currentTime);
                osc.frequency.exponentialRampToValueAtTime(300, audioCtx.currentTime + 0.1);
                gain.gain.setValueAtTime(0.3, audioCtx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.1);
                osc.start();
                osc.stop(audioCtx.currentTime + 0.1);
            } else if (type === 'collect') {
                osc.type = 'triangle';
                osc.frequency.setValueAtTime(400, audioCtx.currentTime);
                osc.frequency.linearRampToValueAtTime(600, audioCtx.currentTime + 0.1);
                gain.gain.setValueAtTime(0.1, audioCtx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.2);
                osc.start();
                osc.stop(audioCtx.currentTime + 0.2);
            }
        }

        /**
         * í´ë˜ìŠ¤ ì •ì˜
         */

        class Particle {
            constructor(x, y, color) {
                this.x = x;
                this.y = y;
                this.vx = (Math.random() - 0.5) * 4;
                this.vy = (Math.random() - 0.5) * 4;
                this.life = 1.0;
                this.color = color;
                this.size = Math.random() * 3 + 2;
            }

            update() {
                this.x += this.vx;
                this.y += this.vy;
                this.life -= 0.03;
            }

            draw(ctx) {
                ctx.globalAlpha = this.life;
                ctx.fillStyle = this.color;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                ctx.fill();
                ctx.globalAlpha = 1.0;
            }
        }

        class Food {
            constructor(x, y) {
                this.x = x;
                this.y = -50; // í•˜ëŠ˜ì—ì„œ ë–¨ì–´ì§
                this.targetY = y;
                this.type = TREATS[Math.floor(Math.random() * TREATS.length)];
                this.state = 'FALLING'; // FALLING, GROUND, CARRIED, STORED
                this.carrier = null; // ìš´ë°˜ ì¤‘ì¸ ê°œë¯¸
                this.decayTime = 0; // ì €ì¥ í›„ ì‚¬ë¼ì§€ëŠ” ì‹œê°„
                this.maxDecayTime = 11000; // ì•½ 11ì´ˆ (ë°€ë¦¬ì´ˆ)
                this.creationTime = Date.now();
                this.rotation = 0;
            }

            update(dt) {
                if (this.state === 'FALLING') {
                    this.y += 10; // ë–¨ì–´ì§€ëŠ” ì†ë„
                    this.rotation += 0.1;
                    if (this.y >= this.targetY) {
                        this.y = this.targetY;
                        this.state = 'GROUND';
                        this.rotation = 0;
                        playSound('drop');
                        // ì°©ì§€ íš¨ê³¼
                        for(let i=0; i<5; i++) {
                            state.particles.push(new Particle(this.x, this.y, '#E0E0E0'));
                        }
                    }
                } else if (this.state === 'STORED') {
                    // ì €ì¥ì†Œì—ì„œ ì„œì„œíˆ ì‚¬ë¼ì§
                    this.decayTime += dt;
                    if (this.decayTime >= this.maxDecayTime) {
                        return false; // ì‚­ì œ ì‹ í˜¸
                    }
                    
                    // ê°‰ì•„ë¨¹íˆëŠ” íš¨ê³¼ (íŒŒí‹°í´)
                    if (Math.random() < 0.1) {
                         state.particles.push(new Particle(this.x + (Math.random()-0.5)*20, this.y + (Math.random()-0.5)*20, '#FFCC00'));
                    }
                }
                return true;
            }

            draw(ctx) {
                ctx.save();
                ctx.translate(this.x, this.y);
                
                if (this.state === 'STORED') {
                    // ì‹œê°„ì´ ì§€ë‚ ìˆ˜ë¡ ì‘ì•„ì§€ê³  íë ¤ì§
                    const progress = this.decayTime / this.maxDecayTime;
                    const scale = 1 - (progress * 0.8); // 20% í¬ê¸°ê¹Œì§€ë§Œ ì¤„ì–´ë“¦
                    ctx.globalAlpha = 1 - progress;
                    ctx.scale(scale, scale);
                } else if (this.state === 'FALLING') {
                    ctx.rotate(this.rotation);
                }

                ctx.font = "30px Arial";
                ctx.textAlign = "center";
                ctx.textBaseline = "middle";
                ctx.fillText(this.type, 0, 0);
                
                ctx.restore();
            }
        }

        class Ant {
            constructor() {
                // ì´ˆê¸° ìœ„ì¹˜: ì—¬ì™•ê°œë¯¸ ë°© ê·¼ì²˜ (ê°€ì¥ ì•„ë˜ìª½ ë°©)
                const spawnRoom = state.rooms[state.rooms.length - 1];
                this.x = spawnRoom.x + (Math.random() - 0.5) * 50;
                this.y = spawnRoom.y + (Math.random() - 0.5) * 20;
                
                this.state = 'IDLE'; // IDLE, SEEKING, CARRYING, RETURNING
                this.targetFood = null;
                this.targetPos = { x: this.x, y: this.y };
                this.speed = 1.5 + Math.random(); // ê°œë¯¸ë§ˆë‹¤ ì†ë„ ë‹¤ë¦„
                this.angle = 0;
                this.wiggle = 0;
                this.holdingFood = null;
            }

            findFood() {
                // ë•… ìœ„ì— ìˆê³ , ì•„ë¬´ë„ ì•ˆ ê°€ì ¸ê°€ëŠ” ìŒì‹ ì°¾ê¸°
                const target = state.foods.find(f => f.state === 'GROUND' && f.carrier === null);
                if (target) {
                    target.carrier = this; // ì°œí•˜ê¸°
                    this.targetFood = target;
                    this.state = 'SEEKING';
                } else {
                    // í•  ì¼ ì—†ìœ¼ë©´ ì§‘ ì•ˆì—ì„œ ë°°íšŒ
                    if (Math.random() < 0.01) {
                        const randomRoom = state.rooms[Math.floor(Math.random() * state.rooms.length)];
                        this.targetPos = { 
                            x: randomRoom.x + (Math.random() - 0.5) * 100,
                            y: randomRoom.y + (Math.random() - 0.5) * 40
                        };
                    }
                }
            }

            moveTowards(x, y) {
                const dx = x - this.x;
                const dy = y - this.y;
                const dist = Math.hypot(dx, dy);
                
                this.angle = Math.atan2(dy, dx);
                
                if (dist > this.speed) {
                    this.x += Math.cos(this.angle) * this.speed;
                    this.y += Math.sin(this.angle) * this.speed;
                    return false; // ë„ì°© ì•ˆí•¨
                } else {
                    this.x = x;
                    this.y = y;
                    return true; // ë„ì°©
                }
            }

            update() {
                this.wiggle += 0.5;

                switch (this.state) {
                    case 'IDLE':
                        this.findFood();
                        this.moveTowards(this.targetPos.x, this.targetPos.y);
                        break;

                    case 'SEEKING':
                        if (!this.targetFood || this.targetFood.state !== 'GROUND') {
                            this.state = 'IDLE';
                            this.targetFood = null;
                            return;
                        }
                        
                        // ì§‘ ì…êµ¬ë¥¼ ê±°ì³ì„œ ì§€ìƒìœ¼ë¡œ ë‚˜ê°€ì•¼ í•¨
                        // ê°„ë‹¨í•œ ê²½ë¡œ: í˜„ì¬ ì§€í•˜ -> ì…êµ¬ -> ìŒì‹
                        if (this.y > state.groundY) {
                            // ì•„ì§ ì§€í•˜ì— ìˆë‹¤ë©´ ì…êµ¬ë¡œ ë¨¼ì € ì´ë™
                             if (this.moveTowards(state.nestEntrance.x, state.nestEntrance.y)) {
                                 // ì…êµ¬ ë„ì°©
                             }
                        } else {
                            // ì§€ìƒì— ìˆë‹¤ë©´ ìŒì‹ìœ¼ë¡œ ì´ë™
                            if (this.moveTowards(this.targetFood.x, this.targetFood.y)) {
                                // ìŒì‹ ë„ì°©, ì¤ê¸°
                                this.targetFood.state = 'CARRIED';
                                this.holdingFood = this.targetFood;
                                this.state = 'RETURNING';
                                
                                // ëœë¤í•œ ì €ì¥ì†Œ ë°© ì„ íƒ
                                const storageRoom = state.rooms[Math.floor(Math.random() * (state.rooms.length - 1))]; // ì—¬ì™•ë°© ì œì™¸
                                this.targetPos = {
                                    x: storageRoom.x + (Math.random()-0.5)*80,
                                    y: storageRoom.y + (Math.random()-0.5)*20
                                };
                            }
                        }
                        break;

                    case 'RETURNING':
                        if (!this.holdingFood) {
                            this.state = 'IDLE';
                            return;
                        }

                        // ìŒì‹ ìœ„ì¹˜ ë™ê¸°í™”
                        this.holdingFood.x = this.x;
                        this.holdingFood.y = this.y - 10;

                        // ì§‘ ì…êµ¬ë¥¼ ê±°ì³ì„œ ë°©ìœ¼ë¡œ ì´ë™
                        if (this.y < state.groundY && Math.abs(this.x - state.nestEntrance.x) > 10) {
                            // ì§€ìƒì— ìˆê³  ì…êµ¬ë‘ ë©€ë©´ ì…êµ¬ë¡œ
                            this.moveTowards(state.nestEntrance.x, state.nestEntrance.y);
                        } else {
                            // ì§€í•˜ë¡œ ì§„ì…í•˜ì—¬ ë°©ìœ¼ë¡œ
                            if (this.moveTowards(this.targetPos.x, this.targetPos.y)) {
                                // ë°© ë„ì°©, ë‚´ë ¤ë†“ê¸°
                                this.holdingFood.state = 'STORED';
                                this.holdingFood = null;
                                this.targetFood = null;
                                this.state = 'IDLE';
                                playSound('collect');
                            }
                        }
                        break;
                }
            }

            draw(ctx) {
                ctx.save();
                ctx.translate(this.x, this.y);
                
                // ë°©í–¥ì— ë”°ë¼ ë’¤ì§‘ê¸°
                if (Math.abs(this.angle) > Math.PI / 2) {
                    ctx.scale(-1, 1);
                }

                // ë‹¤ë¦¬ ê·¸ë¦¬ê¸° (ì›€ì§ì¼ ë•Œ í”ë“¤ë¦¼)
                ctx.strokeStyle = '#000';
                ctx.lineWidth = 1;
                const legOffset = Math.sin(this.wiggle) * 3;
                
                ctx.beginPath();
                ctx.moveTo(3, 3); ctx.lineTo(6 + legOffset, 8);
                ctx.moveTo(-3, 3); ctx.lineTo(-6 - legOffset, 8);
                ctx.moveTo(0, 3); ctx.lineTo(0, 8 - legOffset);
                ctx.stroke();

                // ëª¸í†µ (3ê°œì˜ ì›)
                ctx.fillStyle = '#2c1810'; // ì§™ì€ ê°ˆìƒ‰
                // ë¨¸ë¦¬
                ctx.beginPath(); ctx.arc(4, -2, 3, 0, Math.PI*2); ctx.fill();
                // ê°€ìŠ´
                ctx.beginPath(); ctx.arc(0, 0, 2.5, 0, Math.PI*2); ctx.fill();
                // ë°°
                ctx.beginPath(); ctx.arc(-5, 0, 3.5, 0, Math.PI*2); ctx.fill();

                // ë”ë“¬ì´
                ctx.beginPath();
                ctx.moveTo(5, -3); ctx.lineTo(8, -6);
                ctx.moveTo(5, -3); ctx.lineTo(8, -1);
                ctx.stroke();

                ctx.restore();
            }
        }

        /**
         * ê²Œì„ ë¡œì§
         */

        function resize() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            
            // í™”ë©´ ë¹„ìœ¨ ì„¤ì • (ìƒë‹¨ 30% ì§€ìƒ, í•˜ë‹¨ 70% ì§€í•˜)
            state.groundY = canvas.height * 0.3;
            state.nestEntrance = { x: canvas.width / 2, y: state.groundY };
            
            // ë°© ìœ„ì¹˜ ì¬ì„¤ì •
            const centerX = canvas.width / 2;
            const nestHeight = canvas.height - state.groundY;
            
            state.rooms = [
                // ì¢Œì¸¡ ìƒë‹¨ ë°©
                { x: centerX - 100, y: state.groundY + nestHeight * 0.2, w: 120, h: 60 },
                // ìš°ì¸¡ ìƒë‹¨ ë°©
                { x: centerX + 100, y: state.groundY + nestHeight * 0.3, w: 120, h: 60 },
                // ì¢Œì¸¡ ì¤‘ë‹¨ ë°©
                { x: centerX - 80, y: state.groundY + nestHeight * 0.5, w: 140, h: 70 },
                // ìš°ì¸¡ ì¤‘ë‹¨ ë°©
                { x: centerX + 80, y: state.groundY + nestHeight * 0.6, w: 140, h: 70 },
                // ì—¬ì™•ê°œë¯¸ ë°© (ë§¨ ì•„ë˜ ì¤‘ì•™)
                { x: centerX, y: state.groundY + nestHeight * 0.85, w: 200, h: 80 }
            ];
        }

        function spawnAnt() {
            state.ants.push(new Ant());
            updateUI();
        }

        function handleInput(e) {
            initAudio(); // ì²« í„°ì¹˜ ì‹œ ì˜¤ë””ì˜¤ ì»¨í…ìŠ¤íŠ¸ í™œì„±í™”

            // UI í´ë¦­ ë¬´ì‹œ
            if (e.target.closest('.hud-panel') || e.target.closest('.btn')) return;

            // í„°ì¹˜/ë§ˆìš°ìŠ¤ ì¢Œí‘œ ì •ê·œí™”
            const clientX = e.touches ? e.touches[0].clientX : e.clientX;
            const clientY = e.touches ? e.touches[0].clientY : e.clientY;

            // ë•… ìœ„ì— í„°ì¹˜í–ˆëŠ”ì§€ í™•ì¸
            if (clientY < state.groundY) {
                // ë•… ìœ„ì— ìˆëŠ” ìŒì‹ ê°¯ìˆ˜ ì²´í¬
                const groundFoodCount = state.foods.filter(f => f.state === 'GROUND' || f.state === 'FALLING').length;
                
                if (groundFoodCount < 3) {
                    state.foods.push(new Food(clientX, state.groundY - 15));
                    
                    // í† ìŠ¤íŠ¸ ë©”ì‹œì§€ ìˆ¨ê¹€
                    toast.style.opacity = 0;
                } else {
                    // ì´ë¯¸ ë„ˆë¬´ ë§ìŒ
                    showToast("ì ì‹œë§Œìš”! ê°œë¯¸ë“¤ì´ ë°”ë¹ ìš”!");
                }
            }
        }

        function showToast(msg) {
            toast.innerText = msg;
            toast.style.opacity = 1;
            setTimeout(() => { toast.style.opacity = 0; }, 2000);
        }

        function updateUI() {
            scoreEl.innerText = Math.floor(state.score);
            antCountEl.innerText = state.ants.length;
            
            // ê°œë¯¸ êµ¬ë§¤ ë²„íŠ¼ ìƒíƒœ
            if (state.score >= 50) {
                buyBtn.disabled = false;
                buyBtn.innerText = "ìƒˆ ê°œë¯¸ ë¶€í™” (ì‚¬íƒ• 50ê°œ)";
            } else {
                buyBtn.disabled = true;
                buyBtn.innerText = `ì‚¬íƒ• ëª¨ìœ¼ëŠ” ì¤‘... (${Math.floor(state.score)}/50)`;
            }
        }

        function drawEnvironment() {
            // 1. í•˜ëŠ˜
            ctx.fillStyle = '#87CEEB';
            ctx.fillRect(0, 0, canvas.width, state.groundY);

            // 2. ì§€í•˜ ë°°ê²½ (ì–´ë‘ìš´ í™)
            ctx.fillStyle = '#5D4037';
            ctx.fillRect(0, state.groundY, canvas.width, canvas.height - state.groundY);

            // 3. ì§€ìƒ í’€ìˆ² ë¼ì¸
            ctx.fillStyle = '#4CAF50';
            ctx.fillRect(0, state.groundY - 10, canvas.width, 10);

            // 4. ê°œë¯¸ì§‘ êµ¬ì¡° (í„°ë„ê³¼ ë°©) íŒŒë‚´ê¸°
            ctx.save();
            ctx.beginPath();
            
            // ì¤‘ì•™ ìˆ˜ì§ í„°ë„
            const centerX = canvas.width / 2;
            ctx.moveTo(centerX - 10, state.groundY);
            ctx.lineTo(centerX + 10, state.groundY);
            ctx.lineTo(centerX + 15, canvas.height - 50);
            ctx.lineTo(centerX - 15, canvas.height - 50);
            
            // ë°© ì—°ê²° í„°ë„ë“¤
            state.rooms.forEach(room => {
                ctx.moveTo(centerX, room.y);
                ctx.lineTo(room.x, room.y);
            });
            
            // ê²½ë¡œ ë‹«ê¸° ë° ìŠ¤íƒ€ì¼ë§ (íŒŒë‚¸ ëŠë‚Œ)
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';
            ctx.lineWidth = 20;
            ctx.strokeStyle = '#8D6E63'; // ë°ì€ í™ìƒ‰ (í„°ë„ ë‚´ë¶€)
            ctx.stroke();

            // ë°© ê·¸ë¦¬ê¸°
            state.rooms.forEach(room => {
                // ë°© ë‚´ë¶€
                ctx.fillStyle = '#8D6E63';
                ctx.beginPath();
                ctx.ellipse(room.x, room.y, room.w/2, room.h/2, 0, 0, Math.PI*2);
                ctx.fill();
                
                // ì•½ê°„ì˜ ê·¸ë¦¼ì íš¨ê³¼
                ctx.strokeStyle = '#3E2723';
                ctx.lineWidth = 2;
                ctx.stroke();
            });
            ctx.restore();

            // 5. ì—¬ì™•ê°œë¯¸ ê·¸ë¦¬ê¸° (ê°€ì¥ ì•„ë˜ ë°©)
            const queenRoom = state.rooms[state.rooms.length-1];
            ctx.font = "40px Arial";
            ctx.fillText("ğŸ‘‘ğŸœ", queenRoom.x - 20, queenRoom.y + 10);
        }

        function gameLoop(timestamp) {
            const dt = timestamp - state.lastTime;
            state.lastTime = timestamp;

            // ìº”ë²„ìŠ¤ ì´ˆê¸°í™” (ë®ì–´ì“°ê¸° í•˜ë¯€ë¡œ clearRect êµ³ì´ í•„ìš”ì—†ì§€ë§Œ ì•ˆì „í•˜ê²Œ)
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            drawEnvironment();

            // ìŒì‹ ì—…ë°ì´íŠ¸ ë° ê·¸ë¦¬ê¸°
            state.foods = state.foods.filter(food => {
                const isAlive = food.update(dt);
                if (!isAlive) {
                    // ìŒì‹ì´ ì™„ì „íˆ ë¶„í•´ë¨ -> ì ìˆ˜ ì¦ê°€
                    state.score += 15; // ì‚¬íƒ• í•˜ë‚˜ë‹¹ 15ì 
                    updateUI();
                    
                    // ì ìˆ˜ íšë“ ì´í™íŠ¸
                    for(let i=0; i<8; i++) {
                        state.particles.push(new Particle(food.x, food.y, '#FFD700'));
                    }
                }
                food.draw(ctx);
                return isAlive;
            });

            // ê°œë¯¸ ì—…ë°ì´íŠ¸ ë° ê·¸ë¦¬ê¸°
            state.ants.forEach(ant => {
                ant.update();
                ant.draw(ctx);
            });

            // íŒŒí‹°í´ ì—…ë°ì´íŠ¸ ë° ê·¸ë¦¬ê¸°
            state.particles = state.particles.filter(p => {
                p.update();
                p.draw(ctx);
                return p.life > 0;
            });

            requestAnimationFrame(gameLoop);
        }

        /**
         * ì´ˆê¸°í™” ì‹¤í–‰
         */
        window.addEventListener('resize', resize);
        window.addEventListener('mousedown', handleInput);
        window.addEventListener('touchstart', handleInput, { passive: false });

        buyBtn.addEventListener('click', () => {
            if (state.score >= 50) {
                state.score -= 50;
                spawnAnt();
            }
        });

        // ì´ˆê¸° ì‹¤í–‰
        resize();
        
        // ì´ˆê¸° ê°œë¯¸ 5ë§ˆë¦¬ ìƒì„±
        for(let i=0; i<5; i++) {
            spawnAnt();
        }
        
        // ì•ˆë‚´ ë©”ì‹œì§€
        setTimeout(() => {
            toast.style.opacity = 1;
            setTimeout(() => { toast.style.opacity = 0; }, 3000);
        }, 500);

        requestAnimationFrame(gameLoop);

    </script>
</body>
</html>